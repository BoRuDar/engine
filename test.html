<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.1/lodash.js" language="JavaScript"></script>
</head>
<body>
<script language="JavaScript">

    function describeConst(val) {
        return {
            writable: false,
            enumerable: false,
            configurable: false,
            value: val
        };
    }

    const props = {
        inherits: describeConst(function (SuperClass) {

            const prototype = Object.create(SuperClass.prototype, {
                constructor: describeConst(this),
                superConstructor: describeConst(SuperClass)
            });

            Object.defineProperties(this, {
                prototype: describeConst(prototype),
                Super: describeConst(SuperClass)
            });

            return this;
        })
    };

    _.mixin(_, {

        /**
         * Add class-related behavior to a function, currently this
         * only attaches an .inherits() method.
         *
         * @param  {Constructor} ClassConstructor - The function that should be extended
         * @return {Constructor} - the constructor passed in;
         */
        class: function (ClassConstructor) {
            return Object.defineProperties(ClassConstructor, props);
        }
    });


    //
    var respOpts = {
        "partialRows": false,
        "minimalColumns": false,
        "asAggConfigResults": true
    }

    var esResponse = {
        "took": 13,
        "timed_out": false,
        "_shards": {
            "total": 55,
            "successful": 55,
            "failed": 0
        },
        "hits": {
            "total": 110932,
            "max_score": 0,
            "hits": []
        },
        "aggregations": {
            "2": {
                "buckets": [
                    {
                        "3": {
                            "doc_count_error_upper_bound": 0,
                            "sum_other_doc_count": 0,
                            "buckets": [
                                {
                                    "key": "100",
                                    "doc_count": 3
                                },
                                {
                                    "key": "102",
                                    "doc_count": 2
                                }
                            ]
                        },
                        "key_as_string": "2016-06-01 00:00:00",
                        "key": 1464728400000,
                        "doc_count": 138
                    },
                    {
                        "3": {
                            "doc_count_error_upper_bound": 0,
                            "sum_other_doc_count": 0,
                            "buckets": [
                                {
                                    "key": "100",
                                    "doc_count": 42
                                }
                            ]
                        },
                        "key_as_string": "2016-07-01 00:00:00",
                        "key": 1467320400000,
                        "doc_count": 181
                    },
                    {
                        "3": {
                            "doc_count_error_upper_bound": 0,
                            "sum_other_doc_count": 0,
                            "buckets": [
                                {
                                    "key": "100",
                                    "doc_count": 14
                                }
                            ]
                        },
                        "key_as_string": "2016-08-01 00:00:00",
                        "key": 1469998800000,
                        "doc_count": 100
                    },
                    {
                        "3": {
                            "doc_count_error_upper_bound": 0,
                            "sum_other_doc_count": 0,
                            "buckets": []
                        },
                        "key_as_string": "2016-09-01 00:00:00",
                        "key": 1472677200000,
                        "doc_count": 80
                    },
                    {
                        "3": {
                            "doc_count_error_upper_bound": 0,
                            "sum_other_doc_count": 0,
                            "buckets": [
                                {
                                    "key": "100",
                                    "doc_count": 7
                                }
                            ]
                        },
                        "key_as_string": "2016-10-01 00:00:00",
                        "key": 1475269200000,
                        "doc_count": 294
                    },
                    {
                        "3": {
                            "doc_count_error_upper_bound": 0,
                            "sum_other_doc_count": 104,
                            "buckets": [
                                {
                                    "key": "100",
                                    "doc_count": 161
                                },
                                {
                                    "key": "9999",
                                    "doc_count": 30
                                },
                                {
                                    "key": "99950",
                                    "doc_count": 14
                                },
                                {
                                    "key": "99951",
                                    "doc_count": 14
                                },
                                {
                                    "key": "99952",
                                    "doc_count": 14
                                }
                            ]
                        },
                        "key_as_string": "2016-11-01 00:00:00",
                        "key": 1477951200000,
                        "doc_count": 81193
                    },
                    {
                        "3": {
                            "doc_count_error_upper_bound": 0,
                            "sum_other_doc_count": 0,
                            "buckets": [
                                {
                                    "key": "9999",
                                    "doc_count": 133
                                },
                                {
                                    "key": "102",
                                    "doc_count": 24
                                },
                                {
                                    "key": "100",
                                    "doc_count": 19
                                }
                            ]
                        },
                        "key_as_string": "2016-12-01 00:00:00",
                        "key": 1480543200000,
                        "doc_count": 28946
                    }
                ]
            }
        },
        "status": 200
    }



    var vis = {
        "title": "line",
        "type": "line",
        "params": {
            "shareYAxis": true,
            "addTooltip": true,
            "addLegend": true,
            "legendPosition": "right",
            "showCircles": true,
            "smoothLines": false,
            "interpolate": "linear",
            "scale": "linear",
            "drawLinesBetweenPoints": true,
            "radiusRatio": 9,
            "times": [],
            "addTimeMarker": false,
            "defaultYExtents": false,
            "setYExtents": false,
            "yAxis": {}
        },
        "aggs": [
            {
                "id": "1",
                "enabled": true,
                "type": "count",
                "schema": "metric",
                "params": {}
            },
            {
                "id": "2",
                "enabled": true,
                "type": "date_histogram",
                "schema": "segment",
                "params": {
                    "field": "variables.start_stamp",
                    "interval": "auto",
                    "customInterval": "2h",
                    "min_doc_count": 1,
                    "extended_bounds": {}
                }
            },
            {
                "id": "3",
                "enabled": true,
                "type": "terms",
                "schema": "split",
                "params": {
                    "field": "Destination User",
                    "size": 5,
                    "order": "desc",
                    "orderBy": "1",
                    "row": true
                }
            }
        ],
        "listeners": {}
    }

    var schemasVis = {
        'table': {
            'metric': {
                group: 'metrics',
                name: 'metric'
            },
            'bucket': {
                group: 'buckets',
                name: 'bucket'
            },
            'split': {
                group: 'buckets',
                name: 'split'
            }
        },
        'area': {
            metric: {
                group: 'metrics',
                name: 'metric'
            },
            segment: {
                group: 'buckets',
                name: 'segment'
            },
            group: {
                group: 'buckets',
                name: 'group'
            },
            split: {
                group: 'buckets',
                name: 'split'
            }
        },
        'line': {
            metric: {
                group: 'metrics',
                name: 'metric'
            },
            radius: {
                group: 'metrics',
                name: 'radius'
            },
            segment: {
                group: 'buckets',
                name: 'segment'
            },
            group: {
                group: 'buckets',
                name: 'group'
            },
            split: {
                group: 'buckets',
                name: 'split'
            }
        }
    };

    var dslParams = {
        "date_histogram": function (params = {}) {
            var date_histogram = {time_zone: "Europe/Helsinki"}; //todo

            if (params.field)
                date_histogram.field = params.field;

            if (params.format)
                date_histogram.format = params.format
                ;
            if (params.interval)
                date_histogram.interval = params.customInterval || params.interval;

            if (params.min_doc_count)
                date_histogram.min_doc_count = params.min_doc_count;

            return date_histogram;
        }
    };

    function AggConfig(vis, agg) {
        this.id = agg.id;
        this.params = agg.params;
        this.schema = schemasVis[vis.type][agg.schema]
    }

    AggConfig.prototype.toDsl = function () {

    };

    _.class(SplitAcr).inherits(AggConfigResult);
    function SplitAcr(agg, parent, key) {
        SplitAcr.Super.call(this, agg, parent, key, key);
    }

    function getResponseAggs(_aggs) {
        return getRequestAggs(_aggs).reduce(function (responseValuesAggs, agg) {
            var aggs = agg;
            return aggs ? responseValuesAggs.concat(aggs) : responseValuesAggs;
        }, [])
    }

    function getRequestAggs(_aggs) {
        return _.sortBy(_aggs, function (agg) {
            return (agg.schema.group) === 'metrics' ? 1 : 0;
        });
    }


    var topLevelBucket = Object.assign({},  esResponse.aggregations, {
        doc_count: esResponse.hits.total
    });

    function setSchema(vis) {
        let schema = schemasVis[vis.type];
        vis.aggs.map(function (i) {
            i.schema = schema[i.schema]
        });
    }

    function getColumns(aggs) {
        return getResponseAggs(aggs)
    }

    function collectBucket(write, bucket, key) {
        var agg = write.aggStack.shift();
        if (!agg) {
            console.log(write)
            return;
        }
        switch (agg.schema.group) {
            case "buckets":
                var buckets = new Buckets(bucket[agg.id]);
                if (buckets.length) {
                    var splitting = write.canSplit && agg.schema.name === 'split';
                    if (splitting) {
                        write.split(agg, buckets, function forEachBucket(subBucket, key) {
                            collectBucket(write, subBucket, getKey(subBucket), key);
                        });
                    } else {
                        buckets.forEach(function (subBucket, key) {
                            writer.cell(agg, getKey(subBucket, key), function () {
                                collectBucket(write, subBucket, getKey(subBucket, key));
                            })
                        });
                    }
                } else if (write.partialRows && write.metricsForAllBuckets && write.minimalColumns) {
                    debugger
                } else {
                    write.row();
                }
                break;

            case "metrics":
                var value = getValue(agg.id, bucket, agg.schema.name);
                write.cell(agg, value, function () {
                    if (!write.aggStack.length) {
                        // row complete
                        write.row();
                    } else {
                        // process the next agg at this same level
                        collectBucket(write, bucket, key);
                    }
                });
                break
        }

        write.aggStack.unshift(agg);
    }

    function getValue(id, bucket, schemaName) {
        return isFinite(bucket[id] && bucket[id].value) ? bucket[id].value : bucket.doc_count;
    }

    function getKey(subBucket, key) {
        return subBucket.key_as_string || subBucket.key || key
    }


    function Buckets(aggResp) {
        aggResp = aggResp || false;
        this.buckets = aggResp.buckets || [];
        this.objectMode = _.isPlainObject(this.buckets);

        if (this.objectMode) {
            this._keys = _.keys(this.buckets);
            this.length = this._keys.length;
        } else {
            this.length = this.buckets.length;
        }

        this.forEach = function (fn) {
            let buckets = this.buckets;

            if (this.objectMode) {
                this._keys.forEach(function (key) {
                    fn(buckets[key], key);
                });
            } else {
                buckets.forEach(function (bucket) {
                    fn(bucket, bucket.key);
                });
            }
        }
    }


    function Table() {
        this.columns = null; // written with the first row
        this.rows = [];
    }

    Table.prototype.title = function () {
        return ''
    };


    function TabbedAggResponseWriter(vis, opts) {
        this.vis = vis;
        this.opts = opts || {};
        this.rowBuffer = [];

        let visIsHier = false;

        // do the options allow for splitting? we will only split if true and
        // tabify calls the split method.
        this.canSplit = this.opts.canSplit !== false;

        // should we allow partial rows to be included in the tables? if a
        // partial row is found, it is filled with empty strings ''
        this.partialRows = this.opts.partialRows == null ? visIsHier : this.opts.partialRows;

        // if true, we will not place metric columns after every bucket
        // even if the vis is hierarchical. if false, and the vis is
        // hierarchical, then we will display metric columns after
        // every bucket col
        this.minimalColumns = visIsHier ? !!this.opts.minimalColumns : true;

        // true if we can expect metrics to have been calculated
        // for every bucket
        this.metricsForAllBuckets = visIsHier;

        // if true, values will be wrapped in aggConfigResult objects which link them
        // to their aggConfig and enable the filterbar and tooltip formatters
        this.asAggConfigResults = !!this.opts.asAggConfigResults;

        var aggs = vis.aggs.filter( i => i.enabled === true).map( i => new AggConfig(vis, i));

        this.columns = getColumns(aggs, this.minimalColumns);

        this.aggStack = this.columns;

        this.root = new TableGroup();
        this.acrStack = [];
        this.splitStack = [this.root];
    }

    TabbedAggResponseWriter.prototype.cell = function (agg, value, block) {
        if (this.asAggConfigResults) {
            value = new AggConfigResult(agg, this.acrStack[0], value, value);
        }

        let staskResult = this.asAggConfigResults && value.type === 'bucket';

        this.rowBuffer.push(value);
        if (staskResult) this.acrStack.unshift(value);

        if (_.isFunction(block)) block.call(this);

        this.rowBuffer.pop(value);
        if (staskResult) this.acrStack.shift();

        return value;
    };


    TabbedAggResponseWriter.prototype._table = function (group, agg, key) {
        let Class = (group) ? TableGroup : Table;
        let table = new Class();
        let parent = this.splitStack[0];

        if (group) {
            table.aggConfig = agg;
            table.key = key;
            table.title =  'TODO';
        }

        // link the parent and child
        table.$parent = parent;
        parent.tables.push(table);

        return table;
    };

    TabbedAggResponseWriter.prototype.row = function (buffer) {
        let cells = buffer || this.rowBuffer.slice(0);

        if (!this.partialRows && cells.length < this.columns.length) {
            return;
        }

        let split = this.splitStack[0];
        let table = split.tables[0] || this._table(false);

        while (cells.length < this.columns.length) cells.push('');
        table.rows.push(cells);
        return table;
    };

    TabbedAggResponseWriter.prototype.split = function (agg, buckets, block) {
        let self = this;

        if (!self.canSplit) {
            throw new Error('attempted to split when splitting is disabled');
        }

        self._removeAggFromColumns(agg);

        buckets.forEach(function (bucket, key) {
            // find the existing split that we should extend
            let tableGroup = _.find(self.splitStack[0].tables, { aggConfig: agg, key: key });
            // create the split if it doesn't exist yet
            if (!tableGroup) tableGroup = self._table(true, agg, key);

            let splitAcr = false;
            if (self.asAggConfigResults) {
                splitAcr = self._injectParentSplit(agg, key);
            }

            // push the split onto the stack so that it will receive written tables
            self.splitStack.unshift(tableGroup);

            // call the block
            if (_.isFunction(block)) block.call(self, bucket, key);

            // remove the split from the stack
            self.splitStack.shift();
            splitAcr && _.pull(self.acrStack, splitAcr);
        });
    };

    TabbedAggResponseWriter.prototype._removeAggFromColumns = function (agg) {
        let i = _.findIndex(this.columns, function (col) {
            return col.aggConfig === agg;
        });

        // we must have already removed this column
        if (i === -1) return;

        this.columns.splice(i, 1);

        if (this.minimalColumns) return;

        // hierarchical vis creats additional columns for each bucket
        // we will remove those too
        let mCol = this.columns.splice(i, 1).pop();
        let mI = _.findIndex(this.aggStack, function (agg) {
            return agg === mCol.aggConfig;
        });

        if (mI > -1) this.aggStack.splice(mI, 1);
    };

    /**
     * When a split is found while building the aggConfigResult tree, we
     * want to push the split into the tree at another point. Since each
     * branch in the tree is a double-linked list we need do some special
     * shit to pull this off.
     *
     * @private
     * @param {AggConfig} - The agg which produced the split bucket
     * @param {any} - The value which identifies the bucket
     * @return {SplitAcr} - the AggConfigResult created for the split bucket
     */
    TabbedAggResponseWriter.prototype._injectParentSplit = function (agg, key) {
        let oldList = this.acrStack;
        let newList = this.acrStack = [];

        // walk from right to left through the old stack
        // and move things to the new stack
        let injected = false;

        if (!oldList.length) {
            injected = new SplitAcr(agg, null, key);
            newList.unshift(injected);
            return injected;
        }

        // walk from right to left, emptying the previous list
        while (oldList.length) {
            let acr = oldList.pop();

            // ignore other splits
            if (acr instanceof SplitAcr) {
                newList.unshift(acr);
                continue;
            }

            // inject the split
            if (!injected) {
                injected = new SplitAcr(agg, newList[0], key);
                newList.unshift(injected);
            }

            let newAcr = new AggConfigResult(acr.aggConfig, newList[0], acr.value, getKey(acr));
            newList.unshift(newAcr);

            // and replace the acr in the row buffer if its there
            let rowI = this.rowBuffer.indexOf(acr);
            if (rowI > -1) {
                this.rowBuffer[rowI] = newAcr;
            }
        }

        return injected;
    };

    TabbedAggResponseWriter.prototype.response = function () {
        let columns = this.columns;
        // columns.map(function (col) {
        //   col.title = col.aggConfig.makeLabel();
        // });

        // walk the tree and write the columns to each table
        (function step(table, group) {
            if (table.tables) table.tables.forEach(step);
            else table.columns = columns.slice(0);
        }(this.root));

        if (this.canSplit) return this.root;

        let table = this.root.tables[0];
        if (!table) return;

        delete table.$parent;
        return table;
    };



    function TableGroup() {
        this.aggConfig = null;
        this.key = null;
        this.title = null;
        this.tables = [];
    }

    TableGroup.prototype.field = function () {
        if (this.aggConfig) return this.aggConfig.field();
    };

    TableGroup.prototype.fieldFormatter = function () {
        if (this.aggConfig) return this.aggConfig.fieldFormatter();
    };

    let i = 0;

    function AggConfigResult(aggConfig, parent, value, key) {
        this.key = key;
        this.value = value;
        this.aggConfig = aggConfig;
        this.$parent = parent;
        this.$order = ++i;

        if (aggConfig.schema.group === 'buckets') {
            this.type = 'bucket';
        } else {
            this.type = 'metric';
        }
    }

    /**
     * Returns an array of the aggConfigResult and parents up the branch
     * @returns {array} Array of aggConfigResults
     */
    AggConfigResult.prototype.getPath = function () {
        return (function walk(result, path) {
            path.unshift(result);
            if (result.$parent) return walk(result.$parent, path);
            return path;
        }(this, []));
    };

    /**
     * Returns an Elasticsearch filter that represents the result.
     * @returns {object} Elasticsearch filter
     */
    AggConfigResult.prototype.createFilter = function () {
        return this.aggConfig.createFilter(this.key);
    };

    AggConfigResult.prototype.toString = function (contentType) {
        return this.aggConfig.fieldFormatter(contentType)(this.value);
    };

    AggConfigResult.prototype.valueOf = function () {
        return this.value;
    };

    var writer = new TabbedAggResponseWriter(vis, respOpts);
    collectBucket(writer, topLevelBucket);

    for (let tableGroup of writer.splitStack) {
        for (let table of tableGroup.tables) {
            for (let col of writer.aggStack) {
                if (col.schema.name === 'split') continue;
                console.debug(col.params.customLabel || col.params.field);
            }
            var _rows = [];
            for (let row of table.rows)
                _rows.push(row.map ( i => i.value));

            console.table(_rows)
        }
    }

    
    function toDsl() {
        var dslTopLvl = {};
        var dslLvlCursor = undefined;
        var nestedMetrics = undefined;
        getRequestAggs(vis.aggs).forEach( (config, i, list) => {
            if (!dslLvlCursor) {
                // start at the top level
                dslLvlCursor = dslTopLvl;
            } else {
                let prevConfig = list[i - 1];
                let prevDsl = dslLvlCursor[prevConfig.id];

                // advance the cursor and nest under the previous agg, or
                // put it on the same level if the previous agg doesn't accept
                // sub aggs
                dslLvlCursor = prevDsl.aggs || dslLvlCursor;
            }

            let dsl = dslLvlCursor[config.id] = config.toDsl();
            let subAggs;

            if (config.schema.group === 'buckets' && i < list.length - 1) {
                // buckets that are not the last item in the list accept sub-aggs
                subAggs = dsl.aggs || (dsl.aggs = {});
            }

            if (subAggs && nestedMetrics) {
                nestedMetrics.forEach(function (agg) {
                    subAggs[agg.config.id] = agg.dsl;
                });
            }
        })
    }
    
    console.log(writer);
    
    


</script>

</body>
</html>
